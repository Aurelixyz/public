Option Explicit

' === USTAWIENIA ===
Private Const CHART_NAME As String = "Wykresb"
Private Const ADD_LABELS As Boolean = False
Private Const MARKER_SIZE As Integer = 7

' Automatyczna skala osi
Private Const AUTO_SCALE As Boolean = True
Private Const SCALE_PAD_PCT As Double = 0.1

' === KONFIGURACJA OBSZARU (Kwadratu) ===
Private Const BOX_X_MAX As Double = 80
Private Const BOX_Y_MAX As Double = 5

' Paleta kolorów
Private Function PaletteColors() As Variant
    PaletteColors = Array( _
        RGB(33, 150, 243), RGB(244, 67, 54), RGB(76, 175, 80), _
        RGB(255, 193, 7), RGB(156, 39, 176), RGB(0, 188, 212), _
        RGB(121, 85, 72), RGB(63, 81, 181), RGB(255, 87, 34), _
        RGB(205, 220, 57), RGB(0, 150, 136), RGB(158, 158, 158) _
    )
End Function

Private Function Push(arr As Variant, ByVal val As Variant) As Variant
    Dim n As Long
    If IsEmpty(arr) Then
        ReDim arr(1 To 1)
        arr(1) = val
    Else
        n = UBound(arr) + 1
        ReDim Preserve arr(1 To n)
        arr(n) = val
    End If
    Push = arr
End Function

Private Function FindColumn(ByVal headerRow As Range, ByVal headerName As String) As Long
    Dim c As Range
    For Each c In headerRow.Cells
        If Trim$(LCase$(CStr(c.Value))) = Trim$(LCase$(headerName)) Then
            FindColumn = c.Column
            Exit Function
        End If
    Next c
    FindColumn = 0
End Function

Private Sub DeleteChartIfExists(ByVal ws As Worksheet, ByVal chartName As String)
    Dim co As ChartObject
    For Each co In ws.ChartObjects
        If co.Name = chartName Then
            co.Delete
            Exit For
        End If
    Next co
End Sub

' Zmodernizowana funkcja skalowania - przyjmuje opcjonalne limity "Safety",
' aby upewnić się, że kwadrat jest widoczny.
Private Sub ApplyAutoScaleWithBox(ByVal ch As Chart, ByVal dictX As Object, ByVal dictY As Object, _
                                  Optional ByVal safeMinX As Double = 0, Optional ByVal safeMaxX As Double = 0, _
                                  Optional ByVal safeMinY As Double = 0, Optional ByVal safeMaxY As Double = 0)
    Dim keys As Variant: keys = dictX.keys
    Dim i As Long, arrX As Variant, arrY As Variant
    Dim minX As Double, maxX As Double, minY As Double, maxY As Double
    Dim v As Double
    
    ' Startujemy od "Safety limits" zamiast nieskończoności,
    ' dzięki temu skala na pewno obejmie nasz kwadrat.
    minX = safeMinX: maxX = safeMaxX
    minY = safeMinY: maxY = safeMaxY
    
    ' Jeśli nie podano safe limits (są 0), inicjujemy standardowo, by szukać w danych
    If minX = 0 And maxX = 0 Then
        minX = 1E+308: maxX = -1E+308
    End If
    If minY = 0 And maxY = 0 Then
        minY = 1E+308: maxY = -1E+308
    End If
    
    ' Iteracja po danych
    For i = LBound(keys) To UBound(keys)
        arrX = dictX(keys(i))
        arrY = dictY(keys(i))
        If Not IsEmpty(arrX) And Not IsEmpty(arrY) Then
            Dim p As Long
            For p = LBound(arrX) To UBound(arrX)
                v = arrX(p)
                If v < minX Then minX = v
                If v > maxX Then maxX = v
            Next p
            For p = LBound(arrY) To UBound(arrY)
                v = arrY(p)
                If v < minY Then minY = v
                If v > maxY Then maxY = v
            Next p
        End If
    Next i
    
    If minX > maxX Then Exit Sub ' Brak danych i brak safety limits
    
    Dim padX As Double, padY As Double
    padX = (maxX - minX) * SCALE_PAD_PCT
    padY = (maxY - minY) * SCALE_PAD_PCT
    
    If maxX = minX Then padX = IIf(Abs(minX) > 0, Abs(minX) * SCALE_PAD_PCT, 1)
    If maxY = minY Then padY = IIf(Abs(minY) > 0, Abs(minY) * SCALE_PAD_PCT, 1)
    
    With ch
        ' Oś X
        .Axes(xlCategory).MinimumScale = minX - padX
        .Axes(xlCategory).MaximumScale = maxX + padX
        .Axes(xlCategory).MajorUnit = 10 ' NPS zazwyczaj co 10 lub 20 wygląda lepiej niż 1
        .Axes(xlCategory).TickLabels.NumberFormat = "0"
        
        ' Oś Y
        .Axes(xlValue).MinimumScale = minY - padY
        .Axes(xlValue).MaximumScale = maxY + padY
        .Axes(xlValue).MajorUnit = 1
        .Axes(xlValue).TickLabels.NumberFormat = "0.0" ' EFE często ma ułamki
        
        .Axes(xlCategory).HasMajorGridlines = True
        .Axes(xlValue).HasMajorGridlines = True
    End With
End Sub

Public Sub UtworzWykresKolorWgbu()
    Dim ws As Worksheet: Set ws = ActiveSheet
    Dim rngData As Range
    Dim headerRow As Range
    Dim lastRow As Long, lastCol As Long
    
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    
    On Error GoTo CleanFail
    
    With ws
        lastRow = .Cells(.Rows.Count, 1).End(xlUp).Row
        lastCol = .Cells(1, .Columns.Count).End(xlToLeft).Column
        If lastRow < 2 Then Err.Raise vbObjectError + 7702, , "Brak danych."
        Set rngData = .Range(.Cells(1, 1), .Cells(lastRow, lastCol)).CurrentRegion
    End With
    
    Set headerRow = rngData.Rows(1)
    
    Dim colNrKad As Long, colWydz As Long, colNps As Long, colEfe As Long
    colNrKad = FindColumn(headerRow, "nr_a")
    colWydz = FindColumn(headerRow, "b")
    colNps = FindColumn(headerRow, "nps")
    colEfe = FindColumn(headerRow, "efe")
    
    If colNrKad * colWydz * colNps * colEfe = 0 Then
        Err.Raise vbObjectError + 7701, , "Nie znaleziono wymaganych kolumn."
    End If
    
    Dim dictX As Object, dictY As Object, dictLbl As Object
    Set dictX = CreateObject("Scripting.Dictionary")
    Set dictY = CreateObject("Scripting.Dictionary")
    Set dictLbl = CreateObject("Scripting.Dictionary")
    
    Dim r As Long, npsVal As Variant, efeVal As Variant, wydzKey As String, nrk As String
    
    For r = rngData.Row + 1 To rngData.Row + rngData.Rows.Count - 1
        nrk = CStr(ws.Cells(r, colNrKad).Value)
        wydzKey = Trim$(CStr(ws.Cells(r, colWydz).Value))
        If Len(wydzKey) = 0 Then wydzKey = "Brak c"
        
        npsVal = ws.Cells(r, colNps).Value
        efeVal = ws.Cells(r, colEfe).Value
        
        If IsNumeric(npsVal) And IsNumeric(efeVal) Then
            If Not dictX.Exists(wydzKey) Then
                dictX.Add wydzKey, Empty
                dictY.Add wydzKey, Empty
                dictLbl.Add wydzKey, Empty
            End If
            dictX(wydzKey) = Push(dictX(wydzKey), CDbl(npsVal))
            dictY(wydzKey) = Push(dictY(wydzKey), CDbl(efeVal))
            dictLbl(wydzKey) = Push(dictLbl(wydzKey), nrk)
        End If
    Next r
    
    DeleteChartIfExists ws, CHART_NAME
    
    Dim co As ChartObject
    Set co = ws.ChartObjects.Add( _
        Left:=ws.Range("I4").Left, _
        Top:=ws.Range("I4").Top, _
        Width:=650, Height:=420)
    co.Name = CHART_NAME
    
    With co.Chart
        .ChartType = xlXYScatter
        .HasLegend = True
        .HasTitle = True
        .ChartTitle.Text = "NPS vs EFE — kolor wg c"
        .Axes(xlCategory).HasTitle = True
        .Axes(xlCategory).AxisTitle.Text = "NPS"
        .Axes(xlValue).HasTitle = True
        .Axes(xlValue).AxisTitle.Text = "EFE"
        .PlotArea.Format.Fill.Visible = msoFalse
        .ChartArea.Format.Line.Visible = msoFalse
        .Legend.Position = xlLegendPositionBottom
    End With
    
    Dim keys As Variant: keys = dictX.keys
    Dim pal As Variant: pal = PaletteColors()
    Dim i As Long, clr As Long
    Dim s As Series
    Dim lblArr As Variant
    
    ' 1. Dodajemy serie danych
    If UBound(keys) >= 0 Then
        For i = LBound(keys) To UBound(keys)
            Set s = co.Chart.SeriesCollection.NewSeries
            s.Name = CStr(keys(i))
            s.XValues = dictX(keys(i))
            s.Values = dictY(keys(i))
            
            clr = pal((i - LBound(keys)) Mod (UBound(pal) - LBound(pal) + 1))
            On Error Resume Next
            s.MarkerStyle = xlMarkerStyleCircle
            s.MarkerSize = MARKER_SIZE
            s.MarkerBackgroundColor = clr
            s.MarkerForegroundColor = clr
            s.Format.Line.Visible = msoFalse
            On Error GoTo 0
            
            If ADD_LABELS Then
                s.ApplyDataLabels xlDataLabelsShowLabel
                lblArr = dictLbl(keys(i))
                Dim p As Long
                For p = 1 To UBound(lblArr)
                    s.Points(p).DataLabel.Text = CStr(lblArr(p))
                    s.Points(p).DataLabel.Format.TextFrame2.TextRange.Font.Size = 8
                Next p
            End If
        Next i
    End If
    
    ' 2. Dodanie kwadratu jako serii (na końcu, by był "na wierzchu" lub pod spodem zależnie od potrzeb)
    Dim sBox As Series
    Set sBox = co.Chart.SeriesCollection.NewSeries
    With sBox
        .Name = "Obszar_NPS_LOW" ' Nazwa techniczna
        .XValues = Array(0, BOX_X_MAX, BOX_X_MAX, 0, 0)
        .Values = Array(0, 0, BOX_Y_MAX, BOX_Y_MAX, 0)
        .ChartType = xlXYScatterLinesNoMarkers
        .Format.Line.ForeColor.RGB = RGB(255, 0, 0)
        .Format.Line.Weight = 1.25
        .Format.Line.DashStyle = msoLineDash ' Opcjonalnie przerywana linia dla obszaru
    End With
    
    ' Usunięcie kwadratu z legendy (ostatnia seria)
    On Error Resume Next
    co.Chart.Legend.LegendEntries(co.Chart.SeriesCollection.Count).Delete
    On Error GoTo 0
    
    ' 3. Skalowanie uwzględniające granice kwadratu (0 do 80 na X, 0 do 5 na Y)
    If AUTO_SCALE Then
        ' Podajemy granice kwadratu jako "safety limits", żeby wykres ich nie uciął
        ApplyAutoScaleWithBox co.Chart, dictX, dictY, 0, BOX_X_MAX, 0, BOX_Y_MAX
    End If
    
CleanExit:
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    Exit Sub
CleanFail:
    MsgBox "Błąd: " & Err.Description, vbExclamation, "Makro — wykres wg c"
    Resume CleanExit
End Sub
